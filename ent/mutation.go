// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"study-event-go/ent/charm"
	"study-event-go/ent/charmcreator"
	"study-event-go/ent/charmmodel"
	"study-event-go/ent/garden"
	"study-event-go/ent/lily"
	"study-event-go/ent/lilyskill"
	"study-event-go/ent/mentorship"
	"study-event-go/ent/predicate"
	"study-event-go/ent/skill"
	"study-event-go/types"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCharm        = "Charm"
	TypeCharmCreator = "CharmCreator"
	TypeCharmModel   = "CharmModel"
	TypeGarden       = "Garden"
	TypeLily         = "Lily"
	TypeLilySkill    = "LilySkill"
	TypeMentorship   = "Mentorship"
	TypeSkill        = "Skill"
)

// CharmMutation represents an operation that mutates the Charm nodes in the graph.
type CharmMutation struct {
	config
	op            Op
	typ           string
	id            *types.CharmID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	model_id      *types.CharmModelID
	addmodel_id   *types.CharmModelID
	owner_id      *types.LilyID
	addowner_id   *types.LilyID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Charm, error)
	predicates    []predicate.Charm
}

var _ ent.Mutation = (*CharmMutation)(nil)

// charmOption allows management of the mutation configuration using functional options.
type charmOption func(*CharmMutation)

// newCharmMutation creates new mutation for the Charm entity.
func newCharmMutation(c config, op Op, opts ...charmOption) *CharmMutation {
	m := &CharmMutation{
		config:        c,
		op:            op,
		typ:           TypeCharm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharmID sets the ID field of the mutation.
func withCharmID(id types.CharmID) charmOption {
	return func(m *CharmMutation) {
		var (
			err   error
			once  sync.Once
			value *Charm
		)
		m.oldValue = func(ctx context.Context) (*Charm, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Charm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharm sets the old Charm of the mutation.
func withCharm(node *Charm) charmOption {
	return func(m *CharmMutation) {
		m.oldValue = func(context.Context) (*Charm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Charm entities.
func (m *CharmMutation) SetID(id types.CharmID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharmMutation) ID() (id types.CharmID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CharmMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CharmMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Charm entity.
// If the Charm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CharmMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CharmMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CharmMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Charm entity.
// If the Charm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CharmMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CharmMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CharmMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Charm entity.
// If the Charm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CharmMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[charm.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CharmMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[charm.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CharmMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, charm.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CharmMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharmMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Charm entity.
// If the Charm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharmMutation) ResetName() {
	m.name = nil
}

// SetModelID sets the "model_id" field.
func (m *CharmMutation) SetModelID(tmi types.CharmModelID) {
	m.model_id = &tmi
	m.addmodel_id = nil
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *CharmMutation) ModelID() (r types.CharmModelID, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Charm entity.
// If the Charm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmMutation) OldModelID(ctx context.Context) (v types.CharmModelID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// AddModelID adds tmi to the "model_id" field.
func (m *CharmMutation) AddModelID(tmi types.CharmModelID) {
	if m.addmodel_id != nil {
		*m.addmodel_id += tmi
	} else {
		m.addmodel_id = &tmi
	}
}

// AddedModelID returns the value that was added to the "model_id" field in this mutation.
func (m *CharmMutation) AddedModelID() (r types.CharmModelID, exists bool) {
	v := m.addmodel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetModelID resets all changes to the "model_id" field.
func (m *CharmMutation) ResetModelID() {
	m.model_id = nil
	m.addmodel_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *CharmMutation) SetOwnerID(ti types.LilyID) {
	m.owner_id = &ti
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *CharmMutation) OwnerID() (r types.LilyID, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Charm entity.
// If the Charm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmMutation) OldOwnerID(ctx context.Context) (v types.LilyID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds ti to the "owner_id" field.
func (m *CharmMutation) AddOwnerID(ti types.LilyID) {
	if m.addowner_id != nil {
		*m.addowner_id += ti
	} else {
		m.addowner_id = &ti
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *CharmMutation) AddedOwnerID() (r types.LilyID, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *CharmMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// Where appends a list predicates to the CharmMutation builder.
func (m *CharmMutation) Where(ps ...predicate.Charm) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CharmMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Charm).
func (m *CharmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharmMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, charm.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, charm.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, charm.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, charm.FieldName)
	}
	if m.model_id != nil {
		fields = append(fields, charm.FieldModelID)
	}
	if m.owner_id != nil {
		fields = append(fields, charm.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case charm.FieldCreatedAt:
		return m.CreatedAt()
	case charm.FieldUpdatedAt:
		return m.UpdatedAt()
	case charm.FieldDeletedAt:
		return m.DeletedAt()
	case charm.FieldName:
		return m.Name()
	case charm.FieldModelID:
		return m.ModelID()
	case charm.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case charm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case charm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case charm.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case charm.FieldName:
		return m.OldName(ctx)
	case charm.FieldModelID:
		return m.OldModelID(ctx)
	case charm.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown Charm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case charm.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case charm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case charm.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case charm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case charm.FieldModelID:
		v, ok := value.(types.CharmModelID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case charm.FieldOwnerID:
		v, ok := value.(types.LilyID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown Charm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharmMutation) AddedFields() []string {
	var fields []string
	if m.addmodel_id != nil {
		fields = append(fields, charm.FieldModelID)
	}
	if m.addowner_id != nil {
		fields = append(fields, charm.FieldOwnerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case charm.FieldModelID:
		return m.AddedModelID()
	case charm.FieldOwnerID:
		return m.AddedOwnerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case charm.FieldModelID:
		v, ok := value.(types.CharmModelID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModelID(v)
		return nil
	case charm.FieldOwnerID:
		v, ok := value.(types.LilyID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown Charm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharmMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(charm.FieldDeletedAt) {
		fields = append(fields, charm.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharmMutation) ClearField(name string) error {
	switch name {
	case charm.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Charm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharmMutation) ResetField(name string) error {
	switch name {
	case charm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case charm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case charm.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case charm.FieldName:
		m.ResetName()
		return nil
	case charm.FieldModelID:
		m.ResetModelID()
		return nil
	case charm.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown Charm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharmMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharmMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharmMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharmMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharmMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Charm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharmMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Charm edge %s", name)
}

// CharmCreatorMutation represents an operation that mutates the CharmCreator nodes in the graph.
type CharmCreatorMutation struct {
	config
	op            Op
	typ           string
	id            *types.CharmCreatorID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	_type         *types.ArsenalType
	add_type      *types.ArsenalType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CharmCreator, error)
	predicates    []predicate.CharmCreator
}

var _ ent.Mutation = (*CharmCreatorMutation)(nil)

// charmcreatorOption allows management of the mutation configuration using functional options.
type charmcreatorOption func(*CharmCreatorMutation)

// newCharmCreatorMutation creates new mutation for the CharmCreator entity.
func newCharmCreatorMutation(c config, op Op, opts ...charmcreatorOption) *CharmCreatorMutation {
	m := &CharmCreatorMutation{
		config:        c,
		op:            op,
		typ:           TypeCharmCreator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharmCreatorID sets the ID field of the mutation.
func withCharmCreatorID(id types.CharmCreatorID) charmcreatorOption {
	return func(m *CharmCreatorMutation) {
		var (
			err   error
			once  sync.Once
			value *CharmCreator
		)
		m.oldValue = func(ctx context.Context) (*CharmCreator, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CharmCreator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharmCreator sets the old CharmCreator of the mutation.
func withCharmCreator(node *CharmCreator) charmcreatorOption {
	return func(m *CharmCreatorMutation) {
		m.oldValue = func(context.Context) (*CharmCreator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharmCreatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharmCreatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CharmCreator entities.
func (m *CharmCreatorMutation) SetID(id types.CharmCreatorID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharmCreatorMutation) ID() (id types.CharmCreatorID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CharmCreatorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CharmCreatorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CharmCreator entity.
// If the CharmCreator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmCreatorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CharmCreatorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CharmCreatorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CharmCreatorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CharmCreator entity.
// If the CharmCreator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmCreatorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CharmCreatorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CharmCreatorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CharmCreatorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CharmCreator entity.
// If the CharmCreator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmCreatorMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CharmCreatorMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[charmcreator.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CharmCreatorMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[charmcreator.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CharmCreatorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, charmcreator.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CharmCreatorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharmCreatorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CharmCreator entity.
// If the CharmCreator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmCreatorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharmCreatorMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *CharmCreatorMutation) SetType(tt types.ArsenalType) {
	m._type = &tt
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CharmCreatorMutation) GetType() (r types.ArsenalType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CharmCreator entity.
// If the CharmCreator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmCreatorMutation) OldType(ctx context.Context) (v types.ArsenalType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds tt to the "type" field.
func (m *CharmCreatorMutation) AddType(tt types.ArsenalType) {
	if m.add_type != nil {
		*m.add_type += tt
	} else {
		m.add_type = &tt
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CharmCreatorMutation) AddedType() (r types.ArsenalType, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CharmCreatorMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// Where appends a list predicates to the CharmCreatorMutation builder.
func (m *CharmCreatorMutation) Where(ps ...predicate.CharmCreator) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CharmCreatorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CharmCreator).
func (m *CharmCreatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharmCreatorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, charmcreator.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, charmcreator.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, charmcreator.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, charmcreator.FieldName)
	}
	if m._type != nil {
		fields = append(fields, charmcreator.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharmCreatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case charmcreator.FieldCreatedAt:
		return m.CreatedAt()
	case charmcreator.FieldUpdatedAt:
		return m.UpdatedAt()
	case charmcreator.FieldDeletedAt:
		return m.DeletedAt()
	case charmcreator.FieldName:
		return m.Name()
	case charmcreator.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharmCreatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case charmcreator.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case charmcreator.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case charmcreator.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case charmcreator.FieldName:
		return m.OldName(ctx)
	case charmcreator.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CharmCreator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharmCreatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case charmcreator.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case charmcreator.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case charmcreator.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case charmcreator.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case charmcreator.FieldType:
		v, ok := value.(types.ArsenalType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CharmCreator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharmCreatorMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, charmcreator.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharmCreatorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case charmcreator.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharmCreatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case charmcreator.FieldType:
		v, ok := value.(types.ArsenalType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown CharmCreator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharmCreatorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(charmcreator.FieldDeletedAt) {
		fields = append(fields, charmcreator.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharmCreatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharmCreatorMutation) ClearField(name string) error {
	switch name {
	case charmcreator.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CharmCreator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharmCreatorMutation) ResetField(name string) error {
	switch name {
	case charmcreator.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case charmcreator.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case charmcreator.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case charmcreator.FieldName:
		m.ResetName()
		return nil
	case charmcreator.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CharmCreator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharmCreatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharmCreatorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharmCreatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharmCreatorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharmCreatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharmCreatorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharmCreatorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CharmCreator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharmCreatorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CharmCreator edge %s", name)
}

// CharmModelMutation represents an operation that mutates the CharmModel nodes in the graph.
type CharmModelMutation struct {
	config
	op            Op
	typ           string
	id            *types.CharmModelID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator_id    *types.CharmCreatorID
	addcreator_id *types.CharmCreatorID
	name          *string
	_type         *types.CharmModelType
	add_type      *types.CharmModelType
	generation    *types.CharmModelGeneration
	addgeneration *types.CharmModelGeneration
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CharmModel, error)
	predicates    []predicate.CharmModel
}

var _ ent.Mutation = (*CharmModelMutation)(nil)

// charmmodelOption allows management of the mutation configuration using functional options.
type charmmodelOption func(*CharmModelMutation)

// newCharmModelMutation creates new mutation for the CharmModel entity.
func newCharmModelMutation(c config, op Op, opts ...charmmodelOption) *CharmModelMutation {
	m := &CharmModelMutation{
		config:        c,
		op:            op,
		typ:           TypeCharmModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharmModelID sets the ID field of the mutation.
func withCharmModelID(id types.CharmModelID) charmmodelOption {
	return func(m *CharmModelMutation) {
		var (
			err   error
			once  sync.Once
			value *CharmModel
		)
		m.oldValue = func(ctx context.Context) (*CharmModel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CharmModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharmModel sets the old CharmModel of the mutation.
func withCharmModel(node *CharmModel) charmmodelOption {
	return func(m *CharmModelMutation) {
		m.oldValue = func(context.Context) (*CharmModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharmModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharmModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CharmModel entities.
func (m *CharmModelMutation) SetID(id types.CharmModelID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharmModelMutation) ID() (id types.CharmModelID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CharmModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CharmModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CharmModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CharmModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CharmModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CharmModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CharmModelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CharmModelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CharmModelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[charmmodel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CharmModelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[charmmodel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CharmModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, charmmodel.FieldDeletedAt)
}

// SetCreatorID sets the "creator_id" field.
func (m *CharmModelMutation) SetCreatorID(tci types.CharmCreatorID) {
	m.creator_id = &tci
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *CharmModelMutation) CreatorID() (r types.CharmCreatorID, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldCreatorID(ctx context.Context) (v types.CharmCreatorID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds tci to the "creator_id" field.
func (m *CharmModelMutation) AddCreatorID(tci types.CharmCreatorID) {
	if m.addcreator_id != nil {
		*m.addcreator_id += tci
	} else {
		m.addcreator_id = &tci
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *CharmModelMutation) AddedCreatorID() (r types.CharmCreatorID, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *CharmModelMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
}

// SetName sets the "name" field.
func (m *CharmModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharmModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharmModelMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *CharmModelMutation) SetType(tmt types.CharmModelType) {
	m._type = &tmt
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CharmModelMutation) GetType() (r types.CharmModelType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldType(ctx context.Context) (v types.CharmModelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds tmt to the "type" field.
func (m *CharmModelMutation) AddType(tmt types.CharmModelType) {
	if m.add_type != nil {
		*m.add_type += tmt
	} else {
		m.add_type = &tmt
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CharmModelMutation) AddedType() (r types.CharmModelType, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CharmModelMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetGeneration sets the "generation" field.
func (m *CharmModelMutation) SetGeneration(tmg types.CharmModelGeneration) {
	m.generation = &tmg
	m.addgeneration = nil
}

// Generation returns the value of the "generation" field in the mutation.
func (m *CharmModelMutation) Generation() (r types.CharmModelGeneration, exists bool) {
	v := m.generation
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneration returns the old "generation" field's value of the CharmModel entity.
// If the CharmModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharmModelMutation) OldGeneration(ctx context.Context) (v types.CharmModelGeneration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGeneration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGeneration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneration: %w", err)
	}
	return oldValue.Generation, nil
}

// AddGeneration adds tmg to the "generation" field.
func (m *CharmModelMutation) AddGeneration(tmg types.CharmModelGeneration) {
	if m.addgeneration != nil {
		*m.addgeneration += tmg
	} else {
		m.addgeneration = &tmg
	}
}

// AddedGeneration returns the value that was added to the "generation" field in this mutation.
func (m *CharmModelMutation) AddedGeneration() (r types.CharmModelGeneration, exists bool) {
	v := m.addgeneration
	if v == nil {
		return
	}
	return *v, true
}

// ResetGeneration resets all changes to the "generation" field.
func (m *CharmModelMutation) ResetGeneration() {
	m.generation = nil
	m.addgeneration = nil
}

// Where appends a list predicates to the CharmModelMutation builder.
func (m *CharmModelMutation) Where(ps ...predicate.CharmModel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CharmModelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CharmModel).
func (m *CharmModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharmModelMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, charmmodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, charmmodel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, charmmodel.FieldDeletedAt)
	}
	if m.creator_id != nil {
		fields = append(fields, charmmodel.FieldCreatorID)
	}
	if m.name != nil {
		fields = append(fields, charmmodel.FieldName)
	}
	if m._type != nil {
		fields = append(fields, charmmodel.FieldType)
	}
	if m.generation != nil {
		fields = append(fields, charmmodel.FieldGeneration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharmModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case charmmodel.FieldCreatedAt:
		return m.CreatedAt()
	case charmmodel.FieldUpdatedAt:
		return m.UpdatedAt()
	case charmmodel.FieldDeletedAt:
		return m.DeletedAt()
	case charmmodel.FieldCreatorID:
		return m.CreatorID()
	case charmmodel.FieldName:
		return m.Name()
	case charmmodel.FieldType:
		return m.GetType()
	case charmmodel.FieldGeneration:
		return m.Generation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharmModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case charmmodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case charmmodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case charmmodel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case charmmodel.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case charmmodel.FieldName:
		return m.OldName(ctx)
	case charmmodel.FieldType:
		return m.OldType(ctx)
	case charmmodel.FieldGeneration:
		return m.OldGeneration(ctx)
	}
	return nil, fmt.Errorf("unknown CharmModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharmModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case charmmodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case charmmodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case charmmodel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case charmmodel.FieldCreatorID:
		v, ok := value.(types.CharmCreatorID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case charmmodel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case charmmodel.FieldType:
		v, ok := value.(types.CharmModelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case charmmodel.FieldGeneration:
		v, ok := value.(types.CharmModelGeneration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneration(v)
		return nil
	}
	return fmt.Errorf("unknown CharmModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharmModelMutation) AddedFields() []string {
	var fields []string
	if m.addcreator_id != nil {
		fields = append(fields, charmmodel.FieldCreatorID)
	}
	if m.add_type != nil {
		fields = append(fields, charmmodel.FieldType)
	}
	if m.addgeneration != nil {
		fields = append(fields, charmmodel.FieldGeneration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharmModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case charmmodel.FieldCreatorID:
		return m.AddedCreatorID()
	case charmmodel.FieldType:
		return m.AddedType()
	case charmmodel.FieldGeneration:
		return m.AddedGeneration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharmModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case charmmodel.FieldCreatorID:
		v, ok := value.(types.CharmCreatorID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	case charmmodel.FieldType:
		v, ok := value.(types.CharmModelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case charmmodel.FieldGeneration:
		v, ok := value.(types.CharmModelGeneration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGeneration(v)
		return nil
	}
	return fmt.Errorf("unknown CharmModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharmModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(charmmodel.FieldDeletedAt) {
		fields = append(fields, charmmodel.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharmModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharmModelMutation) ClearField(name string) error {
	switch name {
	case charmmodel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CharmModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharmModelMutation) ResetField(name string) error {
	switch name {
	case charmmodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case charmmodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case charmmodel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case charmmodel.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case charmmodel.FieldName:
		m.ResetName()
		return nil
	case charmmodel.FieldType:
		m.ResetType()
		return nil
	case charmmodel.FieldGeneration:
		m.ResetGeneration()
		return nil
	}
	return fmt.Errorf("unknown CharmModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharmModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharmModelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharmModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharmModelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharmModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharmModelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharmModelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CharmModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharmModelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CharmModel edge %s", name)
}

// GardenMutation represents an operation that mutates the Garden nodes in the graph.
type GardenMutation struct {
	config
	op               Op
	typ              string
	id               *types.GardenID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	location         *string
	mentorship_id    *types.MentorshipID
	addmentorship_id *types.MentorshipID
	legion_system    *types.LegionSystem
	addlegion_system *types.LegionSystem
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Garden, error)
	predicates       []predicate.Garden
}

var _ ent.Mutation = (*GardenMutation)(nil)

// gardenOption allows management of the mutation configuration using functional options.
type gardenOption func(*GardenMutation)

// newGardenMutation creates new mutation for the Garden entity.
func newGardenMutation(c config, op Op, opts ...gardenOption) *GardenMutation {
	m := &GardenMutation{
		config:        c,
		op:            op,
		typ:           TypeGarden,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGardenID sets the ID field of the mutation.
func withGardenID(id types.GardenID) gardenOption {
	return func(m *GardenMutation) {
		var (
			err   error
			once  sync.Once
			value *Garden
		)
		m.oldValue = func(ctx context.Context) (*Garden, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Garden.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGarden sets the old Garden of the mutation.
func withGarden(node *Garden) gardenOption {
	return func(m *GardenMutation) {
		m.oldValue = func(context.Context) (*Garden, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GardenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GardenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Garden entities.
func (m *GardenMutation) SetID(id types.GardenID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GardenMutation) ID() (id types.GardenID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GardenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GardenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GardenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GardenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GardenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GardenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GardenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GardenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GardenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[garden.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GardenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[garden.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GardenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, garden.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *GardenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GardenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GardenMutation) ResetName() {
	m.name = nil
}

// SetLocation sets the "location" field.
func (m *GardenMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *GardenMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *GardenMutation) ResetLocation() {
	m.location = nil
}

// SetMentorshipID sets the "mentorship_id" field.
func (m *GardenMutation) SetMentorshipID(ti types.MentorshipID) {
	m.mentorship_id = &ti
	m.addmentorship_id = nil
}

// MentorshipID returns the value of the "mentorship_id" field in the mutation.
func (m *GardenMutation) MentorshipID() (r types.MentorshipID, exists bool) {
	v := m.mentorship_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMentorshipID returns the old "mentorship_id" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldMentorshipID(ctx context.Context) (v types.MentorshipID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMentorshipID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMentorshipID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMentorshipID: %w", err)
	}
	return oldValue.MentorshipID, nil
}

// AddMentorshipID adds ti to the "mentorship_id" field.
func (m *GardenMutation) AddMentorshipID(ti types.MentorshipID) {
	if m.addmentorship_id != nil {
		*m.addmentorship_id += ti
	} else {
		m.addmentorship_id = &ti
	}
}

// AddedMentorshipID returns the value that was added to the "mentorship_id" field in this mutation.
func (m *GardenMutation) AddedMentorshipID() (r types.MentorshipID, exists bool) {
	v := m.addmentorship_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMentorshipID resets all changes to the "mentorship_id" field.
func (m *GardenMutation) ResetMentorshipID() {
	m.mentorship_id = nil
	m.addmentorship_id = nil
}

// SetLegionSystem sets the "legion_system" field.
func (m *GardenMutation) SetLegionSystem(ts types.LegionSystem) {
	m.legion_system = &ts
	m.addlegion_system = nil
}

// LegionSystem returns the value of the "legion_system" field in the mutation.
func (m *GardenMutation) LegionSystem() (r types.LegionSystem, exists bool) {
	v := m.legion_system
	if v == nil {
		return
	}
	return *v, true
}

// OldLegionSystem returns the old "legion_system" field's value of the Garden entity.
// If the Garden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GardenMutation) OldLegionSystem(ctx context.Context) (v types.LegionSystem, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLegionSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLegionSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegionSystem: %w", err)
	}
	return oldValue.LegionSystem, nil
}

// AddLegionSystem adds ts to the "legion_system" field.
func (m *GardenMutation) AddLegionSystem(ts types.LegionSystem) {
	if m.addlegion_system != nil {
		*m.addlegion_system += ts
	} else {
		m.addlegion_system = &ts
	}
}

// AddedLegionSystem returns the value that was added to the "legion_system" field in this mutation.
func (m *GardenMutation) AddedLegionSystem() (r types.LegionSystem, exists bool) {
	v := m.addlegion_system
	if v == nil {
		return
	}
	return *v, true
}

// ResetLegionSystem resets all changes to the "legion_system" field.
func (m *GardenMutation) ResetLegionSystem() {
	m.legion_system = nil
	m.addlegion_system = nil
}

// Where appends a list predicates to the GardenMutation builder.
func (m *GardenMutation) Where(ps ...predicate.Garden) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GardenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Garden).
func (m *GardenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GardenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, garden.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, garden.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, garden.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, garden.FieldName)
	}
	if m.location != nil {
		fields = append(fields, garden.FieldLocation)
	}
	if m.mentorship_id != nil {
		fields = append(fields, garden.FieldMentorshipID)
	}
	if m.legion_system != nil {
		fields = append(fields, garden.FieldLegionSystem)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GardenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case garden.FieldCreatedAt:
		return m.CreatedAt()
	case garden.FieldUpdatedAt:
		return m.UpdatedAt()
	case garden.FieldDeletedAt:
		return m.DeletedAt()
	case garden.FieldName:
		return m.Name()
	case garden.FieldLocation:
		return m.Location()
	case garden.FieldMentorshipID:
		return m.MentorshipID()
	case garden.FieldLegionSystem:
		return m.LegionSystem()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GardenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case garden.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case garden.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case garden.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case garden.FieldName:
		return m.OldName(ctx)
	case garden.FieldLocation:
		return m.OldLocation(ctx)
	case garden.FieldMentorshipID:
		return m.OldMentorshipID(ctx)
	case garden.FieldLegionSystem:
		return m.OldLegionSystem(ctx)
	}
	return nil, fmt.Errorf("unknown Garden field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GardenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case garden.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case garden.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case garden.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case garden.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case garden.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case garden.FieldMentorshipID:
		v, ok := value.(types.MentorshipID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMentorshipID(v)
		return nil
	case garden.FieldLegionSystem:
		v, ok := value.(types.LegionSystem)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegionSystem(v)
		return nil
	}
	return fmt.Errorf("unknown Garden field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GardenMutation) AddedFields() []string {
	var fields []string
	if m.addmentorship_id != nil {
		fields = append(fields, garden.FieldMentorshipID)
	}
	if m.addlegion_system != nil {
		fields = append(fields, garden.FieldLegionSystem)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GardenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case garden.FieldMentorshipID:
		return m.AddedMentorshipID()
	case garden.FieldLegionSystem:
		return m.AddedLegionSystem()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GardenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case garden.FieldMentorshipID:
		v, ok := value.(types.MentorshipID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMentorshipID(v)
		return nil
	case garden.FieldLegionSystem:
		v, ok := value.(types.LegionSystem)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLegionSystem(v)
		return nil
	}
	return fmt.Errorf("unknown Garden numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GardenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(garden.FieldDeletedAt) {
		fields = append(fields, garden.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GardenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GardenMutation) ClearField(name string) error {
	switch name {
	case garden.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Garden nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GardenMutation) ResetField(name string) error {
	switch name {
	case garden.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case garden.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case garden.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case garden.FieldName:
		m.ResetName()
		return nil
	case garden.FieldLocation:
		m.ResetLocation()
		return nil
	case garden.FieldMentorshipID:
		m.ResetMentorshipID()
		return nil
	case garden.FieldLegionSystem:
		m.ResetLegionSystem()
		return nil
	}
	return fmt.Errorf("unknown Garden field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GardenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GardenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GardenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GardenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GardenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GardenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GardenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Garden unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GardenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Garden edge %s", name)
}

// LilyMutation represents an operation that mutates the Lily nodes in the graph.
type LilyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *types.LilyID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	cause_of_deletion    *types.CauseOfDeletion
	addcause_of_deletion *types.CauseOfDeletion
	birth                *time.Time
	first_name           *string
	middle_name          *string
	last_name            *string
	rank                 *uint32
	addrank              *uint32
	garden_id            *types.GardenID
	addgarden_id         *types.GardenID
	legion_id            *types.LegionID
	addlegion_id         *types.LegionID
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Lily, error)
	predicates           []predicate.Lily
}

var _ ent.Mutation = (*LilyMutation)(nil)

// lilyOption allows management of the mutation configuration using functional options.
type lilyOption func(*LilyMutation)

// newLilyMutation creates new mutation for the Lily entity.
func newLilyMutation(c config, op Op, opts ...lilyOption) *LilyMutation {
	m := &LilyMutation{
		config:        c,
		op:            op,
		typ:           TypeLily,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLilyID sets the ID field of the mutation.
func withLilyID(id types.LilyID) lilyOption {
	return func(m *LilyMutation) {
		var (
			err   error
			once  sync.Once
			value *Lily
		)
		m.oldValue = func(ctx context.Context) (*Lily, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lily.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLily sets the old Lily of the mutation.
func withLily(node *Lily) lilyOption {
	return func(m *LilyMutation) {
		m.oldValue = func(context.Context) (*Lily, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LilyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LilyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lily entities.
func (m *LilyMutation) SetID(id types.LilyID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LilyMutation) ID() (id types.LilyID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *LilyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LilyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LilyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LilyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LilyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LilyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LilyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LilyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LilyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[lily.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LilyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[lily.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LilyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, lily.FieldDeletedAt)
}

// SetCauseOfDeletion sets the "cause_of_deletion" field.
func (m *LilyMutation) SetCauseOfDeletion(tod types.CauseOfDeletion) {
	m.cause_of_deletion = &tod
	m.addcause_of_deletion = nil
}

// CauseOfDeletion returns the value of the "cause_of_deletion" field in the mutation.
func (m *LilyMutation) CauseOfDeletion() (r types.CauseOfDeletion, exists bool) {
	v := m.cause_of_deletion
	if v == nil {
		return
	}
	return *v, true
}

// OldCauseOfDeletion returns the old "cause_of_deletion" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldCauseOfDeletion(ctx context.Context) (v types.CauseOfDeletion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCauseOfDeletion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCauseOfDeletion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCauseOfDeletion: %w", err)
	}
	return oldValue.CauseOfDeletion, nil
}

// AddCauseOfDeletion adds tod to the "cause_of_deletion" field.
func (m *LilyMutation) AddCauseOfDeletion(tod types.CauseOfDeletion) {
	if m.addcause_of_deletion != nil {
		*m.addcause_of_deletion += tod
	} else {
		m.addcause_of_deletion = &tod
	}
}

// AddedCauseOfDeletion returns the value that was added to the "cause_of_deletion" field in this mutation.
func (m *LilyMutation) AddedCauseOfDeletion() (r types.CauseOfDeletion, exists bool) {
	v := m.addcause_of_deletion
	if v == nil {
		return
	}
	return *v, true
}

// ResetCauseOfDeletion resets all changes to the "cause_of_deletion" field.
func (m *LilyMutation) ResetCauseOfDeletion() {
	m.cause_of_deletion = nil
	m.addcause_of_deletion = nil
}

// SetBirth sets the "birth" field.
func (m *LilyMutation) SetBirth(t time.Time) {
	m.birth = &t
}

// Birth returns the value of the "birth" field in the mutation.
func (m *LilyMutation) Birth() (r time.Time, exists bool) {
	v := m.birth
	if v == nil {
		return
	}
	return *v, true
}

// OldBirth returns the old "birth" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldBirth(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirth: %w", err)
	}
	return oldValue.Birth, nil
}

// ClearBirth clears the value of the "birth" field.
func (m *LilyMutation) ClearBirth() {
	m.birth = nil
	m.clearedFields[lily.FieldBirth] = struct{}{}
}

// BirthCleared returns if the "birth" field was cleared in this mutation.
func (m *LilyMutation) BirthCleared() bool {
	_, ok := m.clearedFields[lily.FieldBirth]
	return ok
}

// ResetBirth resets all changes to the "birth" field.
func (m *LilyMutation) ResetBirth() {
	m.birth = nil
	delete(m.clearedFields, lily.FieldBirth)
}

// SetFirstName sets the "first_name" field.
func (m *LilyMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *LilyMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *LilyMutation) ResetFirstName() {
	m.first_name = nil
}

// SetMiddleName sets the "middle_name" field.
func (m *LilyMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *LilyMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *LilyMutation) ResetMiddleName() {
	m.middle_name = nil
}

// SetLastName sets the "last_name" field.
func (m *LilyMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *LilyMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *LilyMutation) ResetLastName() {
	m.last_name = nil
}

// SetRank sets the "rank" field.
func (m *LilyMutation) SetRank(u uint32) {
	m.rank = &u
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *LilyMutation) Rank() (r uint32, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldRank(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds u to the "rank" field.
func (m *LilyMutation) AddRank(u uint32) {
	if m.addrank != nil {
		*m.addrank += u
	} else {
		m.addrank = &u
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *LilyMutation) AddedRank() (r uint32, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *LilyMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetGardenID sets the "garden_id" field.
func (m *LilyMutation) SetGardenID(ti types.GardenID) {
	m.garden_id = &ti
	m.addgarden_id = nil
}

// GardenID returns the value of the "garden_id" field in the mutation.
func (m *LilyMutation) GardenID() (r types.GardenID, exists bool) {
	v := m.garden_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGardenID returns the old "garden_id" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldGardenID(ctx context.Context) (v types.GardenID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGardenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGardenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGardenID: %w", err)
	}
	return oldValue.GardenID, nil
}

// AddGardenID adds ti to the "garden_id" field.
func (m *LilyMutation) AddGardenID(ti types.GardenID) {
	if m.addgarden_id != nil {
		*m.addgarden_id += ti
	} else {
		m.addgarden_id = &ti
	}
}

// AddedGardenID returns the value that was added to the "garden_id" field in this mutation.
func (m *LilyMutation) AddedGardenID() (r types.GardenID, exists bool) {
	v := m.addgarden_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGardenID resets all changes to the "garden_id" field.
func (m *LilyMutation) ResetGardenID() {
	m.garden_id = nil
	m.addgarden_id = nil
}

// SetLegionID sets the "legion_id" field.
func (m *LilyMutation) SetLegionID(ti types.LegionID) {
	m.legion_id = &ti
	m.addlegion_id = nil
}

// LegionID returns the value of the "legion_id" field in the mutation.
func (m *LilyMutation) LegionID() (r types.LegionID, exists bool) {
	v := m.legion_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLegionID returns the old "legion_id" field's value of the Lily entity.
// If the Lily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilyMutation) OldLegionID(ctx context.Context) (v types.LegionID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegionID: %w", err)
	}
	return oldValue.LegionID, nil
}

// AddLegionID adds ti to the "legion_id" field.
func (m *LilyMutation) AddLegionID(ti types.LegionID) {
	if m.addlegion_id != nil {
		*m.addlegion_id += ti
	} else {
		m.addlegion_id = &ti
	}
}

// AddedLegionID returns the value that was added to the "legion_id" field in this mutation.
func (m *LilyMutation) AddedLegionID() (r types.LegionID, exists bool) {
	v := m.addlegion_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLegionID resets all changes to the "legion_id" field.
func (m *LilyMutation) ResetLegionID() {
	m.legion_id = nil
	m.addlegion_id = nil
}

// Where appends a list predicates to the LilyMutation builder.
func (m *LilyMutation) Where(ps ...predicate.Lily) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LilyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Lily).
func (m *LilyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LilyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, lily.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lily.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, lily.FieldDeletedAt)
	}
	if m.cause_of_deletion != nil {
		fields = append(fields, lily.FieldCauseOfDeletion)
	}
	if m.birth != nil {
		fields = append(fields, lily.FieldBirth)
	}
	if m.first_name != nil {
		fields = append(fields, lily.FieldFirstName)
	}
	if m.middle_name != nil {
		fields = append(fields, lily.FieldMiddleName)
	}
	if m.last_name != nil {
		fields = append(fields, lily.FieldLastName)
	}
	if m.rank != nil {
		fields = append(fields, lily.FieldRank)
	}
	if m.garden_id != nil {
		fields = append(fields, lily.FieldGardenID)
	}
	if m.legion_id != nil {
		fields = append(fields, lily.FieldLegionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LilyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lily.FieldCreatedAt:
		return m.CreatedAt()
	case lily.FieldUpdatedAt:
		return m.UpdatedAt()
	case lily.FieldDeletedAt:
		return m.DeletedAt()
	case lily.FieldCauseOfDeletion:
		return m.CauseOfDeletion()
	case lily.FieldBirth:
		return m.Birth()
	case lily.FieldFirstName:
		return m.FirstName()
	case lily.FieldMiddleName:
		return m.MiddleName()
	case lily.FieldLastName:
		return m.LastName()
	case lily.FieldRank:
		return m.Rank()
	case lily.FieldGardenID:
		return m.GardenID()
	case lily.FieldLegionID:
		return m.LegionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LilyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lily.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lily.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lily.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case lily.FieldCauseOfDeletion:
		return m.OldCauseOfDeletion(ctx)
	case lily.FieldBirth:
		return m.OldBirth(ctx)
	case lily.FieldFirstName:
		return m.OldFirstName(ctx)
	case lily.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case lily.FieldLastName:
		return m.OldLastName(ctx)
	case lily.FieldRank:
		return m.OldRank(ctx)
	case lily.FieldGardenID:
		return m.OldGardenID(ctx)
	case lily.FieldLegionID:
		return m.OldLegionID(ctx)
	}
	return nil, fmt.Errorf("unknown Lily field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LilyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lily.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lily.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lily.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case lily.FieldCauseOfDeletion:
		v, ok := value.(types.CauseOfDeletion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCauseOfDeletion(v)
		return nil
	case lily.FieldBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirth(v)
		return nil
	case lily.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case lily.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case lily.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case lily.FieldRank:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case lily.FieldGardenID:
		v, ok := value.(types.GardenID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGardenID(v)
		return nil
	case lily.FieldLegionID:
		v, ok := value.(types.LegionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegionID(v)
		return nil
	}
	return fmt.Errorf("unknown Lily field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LilyMutation) AddedFields() []string {
	var fields []string
	if m.addcause_of_deletion != nil {
		fields = append(fields, lily.FieldCauseOfDeletion)
	}
	if m.addrank != nil {
		fields = append(fields, lily.FieldRank)
	}
	if m.addgarden_id != nil {
		fields = append(fields, lily.FieldGardenID)
	}
	if m.addlegion_id != nil {
		fields = append(fields, lily.FieldLegionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LilyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lily.FieldCauseOfDeletion:
		return m.AddedCauseOfDeletion()
	case lily.FieldRank:
		return m.AddedRank()
	case lily.FieldGardenID:
		return m.AddedGardenID()
	case lily.FieldLegionID:
		return m.AddedLegionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LilyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lily.FieldCauseOfDeletion:
		v, ok := value.(types.CauseOfDeletion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCauseOfDeletion(v)
		return nil
	case lily.FieldRank:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case lily.FieldGardenID:
		v, ok := value.(types.GardenID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGardenID(v)
		return nil
	case lily.FieldLegionID:
		v, ok := value.(types.LegionID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLegionID(v)
		return nil
	}
	return fmt.Errorf("unknown Lily numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LilyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lily.FieldDeletedAt) {
		fields = append(fields, lily.FieldDeletedAt)
	}
	if m.FieldCleared(lily.FieldBirth) {
		fields = append(fields, lily.FieldBirth)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LilyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LilyMutation) ClearField(name string) error {
	switch name {
	case lily.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case lily.FieldBirth:
		m.ClearBirth()
		return nil
	}
	return fmt.Errorf("unknown Lily nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LilyMutation) ResetField(name string) error {
	switch name {
	case lily.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lily.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lily.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case lily.FieldCauseOfDeletion:
		m.ResetCauseOfDeletion()
		return nil
	case lily.FieldBirth:
		m.ResetBirth()
		return nil
	case lily.FieldFirstName:
		m.ResetFirstName()
		return nil
	case lily.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case lily.FieldLastName:
		m.ResetLastName()
		return nil
	case lily.FieldRank:
		m.ResetRank()
		return nil
	case lily.FieldGardenID:
		m.ResetGardenID()
		return nil
	case lily.FieldLegionID:
		m.ResetLegionID()
		return nil
	}
	return fmt.Errorf("unknown Lily field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LilyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LilyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LilyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LilyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LilyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LilyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LilyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Lily unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LilyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Lily edge %s", name)
}

// LilySkillMutation represents an operation that mutates the LilySkill nodes in the graph.
type LilySkillMutation struct {
	config
	op            Op
	typ           string
	id            *int
	lily_id       *types.LilyID
	addlily_id    *types.LilyID
	skill_id      *types.SkillID
	addskill_id   *types.SkillID
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LilySkill, error)
	predicates    []predicate.LilySkill
}

var _ ent.Mutation = (*LilySkillMutation)(nil)

// lilyskillOption allows management of the mutation configuration using functional options.
type lilyskillOption func(*LilySkillMutation)

// newLilySkillMutation creates new mutation for the LilySkill entity.
func newLilySkillMutation(c config, op Op, opts ...lilyskillOption) *LilySkillMutation {
	m := &LilySkillMutation{
		config:        c,
		op:            op,
		typ:           TypeLilySkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLilySkillID sets the ID field of the mutation.
func withLilySkillID(id int) lilyskillOption {
	return func(m *LilySkillMutation) {
		var (
			err   error
			once  sync.Once
			value *LilySkill
		)
		m.oldValue = func(ctx context.Context) (*LilySkill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LilySkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLilySkill sets the old LilySkill of the mutation.
func withLilySkill(node *LilySkill) lilyskillOption {
	return func(m *LilySkillMutation) {
		m.oldValue = func(context.Context) (*LilySkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LilySkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LilySkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LilySkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLilyID sets the "lily_id" field.
func (m *LilySkillMutation) SetLilyID(ti types.LilyID) {
	m.lily_id = &ti
	m.addlily_id = nil
}

// LilyID returns the value of the "lily_id" field in the mutation.
func (m *LilySkillMutation) LilyID() (r types.LilyID, exists bool) {
	v := m.lily_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLilyID returns the old "lily_id" field's value of the LilySkill entity.
// If the LilySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilySkillMutation) OldLilyID(ctx context.Context) (v types.LilyID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLilyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLilyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLilyID: %w", err)
	}
	return oldValue.LilyID, nil
}

// AddLilyID adds ti to the "lily_id" field.
func (m *LilySkillMutation) AddLilyID(ti types.LilyID) {
	if m.addlily_id != nil {
		*m.addlily_id += ti
	} else {
		m.addlily_id = &ti
	}
}

// AddedLilyID returns the value that was added to the "lily_id" field in this mutation.
func (m *LilySkillMutation) AddedLilyID() (r types.LilyID, exists bool) {
	v := m.addlily_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLilyID resets all changes to the "lily_id" field.
func (m *LilySkillMutation) ResetLilyID() {
	m.lily_id = nil
	m.addlily_id = nil
}

// SetSkillID sets the "skill_id" field.
func (m *LilySkillMutation) SetSkillID(ti types.SkillID) {
	m.skill_id = &ti
	m.addskill_id = nil
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *LilySkillMutation) SkillID() (r types.SkillID, exists bool) {
	v := m.skill_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the LilySkill entity.
// If the LilySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilySkillMutation) OldSkillID(ctx context.Context) (v types.SkillID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// AddSkillID adds ti to the "skill_id" field.
func (m *LilySkillMutation) AddSkillID(ti types.SkillID) {
	if m.addskill_id != nil {
		*m.addskill_id += ti
	} else {
		m.addskill_id = &ti
	}
}

// AddedSkillID returns the value that was added to the "skill_id" field in this mutation.
func (m *LilySkillMutation) AddedSkillID() (r types.SkillID, exists bool) {
	v := m.addskill_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *LilySkillMutation) ResetSkillID() {
	m.skill_id = nil
	m.addskill_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LilySkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LilySkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LilySkill entity.
// If the LilySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilySkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LilySkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LilySkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LilySkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LilySkill entity.
// If the LilySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LilySkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LilySkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the LilySkillMutation builder.
func (m *LilySkillMutation) Where(ps ...predicate.LilySkill) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LilySkillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LilySkill).
func (m *LilySkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LilySkillMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.lily_id != nil {
		fields = append(fields, lilyskill.FieldLilyID)
	}
	if m.skill_id != nil {
		fields = append(fields, lilyskill.FieldSkillID)
	}
	if m.created_at != nil {
		fields = append(fields, lilyskill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lilyskill.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LilySkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lilyskill.FieldLilyID:
		return m.LilyID()
	case lilyskill.FieldSkillID:
		return m.SkillID()
	case lilyskill.FieldCreatedAt:
		return m.CreatedAt()
	case lilyskill.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LilySkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lilyskill.FieldLilyID:
		return m.OldLilyID(ctx)
	case lilyskill.FieldSkillID:
		return m.OldSkillID(ctx)
	case lilyskill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lilyskill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LilySkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LilySkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lilyskill.FieldLilyID:
		v, ok := value.(types.LilyID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLilyID(v)
		return nil
	case lilyskill.FieldSkillID:
		v, ok := value.(types.SkillID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case lilyskill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lilyskill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LilySkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LilySkillMutation) AddedFields() []string {
	var fields []string
	if m.addlily_id != nil {
		fields = append(fields, lilyskill.FieldLilyID)
	}
	if m.addskill_id != nil {
		fields = append(fields, lilyskill.FieldSkillID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LilySkillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lilyskill.FieldLilyID:
		return m.AddedLilyID()
	case lilyskill.FieldSkillID:
		return m.AddedSkillID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LilySkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lilyskill.FieldLilyID:
		v, ok := value.(types.LilyID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLilyID(v)
		return nil
	case lilyskill.FieldSkillID:
		v, ok := value.(types.SkillID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkillID(v)
		return nil
	}
	return fmt.Errorf("unknown LilySkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LilySkillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LilySkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LilySkillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LilySkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LilySkillMutation) ResetField(name string) error {
	switch name {
	case lilyskill.FieldLilyID:
		m.ResetLilyID()
		return nil
	case lilyskill.FieldSkillID:
		m.ResetSkillID()
		return nil
	case lilyskill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lilyskill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LilySkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LilySkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LilySkillMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LilySkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LilySkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LilySkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LilySkillMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LilySkillMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LilySkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LilySkillMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LilySkill edge %s", name)
}

// MentorshipMutation represents an operation that mutates the Mentorship nodes in the graph.
type MentorshipMutation struct {
	config
	op            Op
	typ           string
	id            *types.MentorshipID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Mentorship, error)
	predicates    []predicate.Mentorship
}

var _ ent.Mutation = (*MentorshipMutation)(nil)

// mentorshipOption allows management of the mutation configuration using functional options.
type mentorshipOption func(*MentorshipMutation)

// newMentorshipMutation creates new mutation for the Mentorship entity.
func newMentorshipMutation(c config, op Op, opts ...mentorshipOption) *MentorshipMutation {
	m := &MentorshipMutation{
		config:        c,
		op:            op,
		typ:           TypeMentorship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentorshipID sets the ID field of the mutation.
func withMentorshipID(id types.MentorshipID) mentorshipOption {
	return func(m *MentorshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Mentorship
		)
		m.oldValue = func(ctx context.Context) (*Mentorship, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mentorship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMentorship sets the old Mentorship of the mutation.
func withMentorship(node *Mentorship) mentorshipOption {
	return func(m *MentorshipMutation) {
		m.oldValue = func(context.Context) (*Mentorship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentorshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentorshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mentorship entities.
func (m *MentorshipMutation) SetID(id types.MentorshipID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentorshipMutation) ID() (id types.MentorshipID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MentorshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MentorshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mentorship entity.
// If the Mentorship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MentorshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MentorshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MentorshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mentorship entity.
// If the Mentorship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MentorshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MentorshipMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MentorshipMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Mentorship entity.
// If the Mentorship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MentorshipMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mentorship.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MentorshipMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mentorship.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MentorshipMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mentorship.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MentorshipMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MentorshipMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Mentorship entity.
// If the Mentorship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MentorshipMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the MentorshipMutation builder.
func (m *MentorshipMutation) Where(ps ...predicate.Mentorship) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MentorshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Mentorship).
func (m *MentorshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentorshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, mentorship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mentorship.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mentorship.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, mentorship.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentorshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mentorship.FieldCreatedAt:
		return m.CreatedAt()
	case mentorship.FieldUpdatedAt:
		return m.UpdatedAt()
	case mentorship.FieldDeletedAt:
		return m.DeletedAt()
	case mentorship.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentorshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mentorship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mentorship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mentorship.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mentorship.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Mentorship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mentorship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mentorship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mentorship.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mentorship.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Mentorship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentorshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentorshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mentorship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentorshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mentorship.FieldDeletedAt) {
		fields = append(fields, mentorship.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentorshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentorshipMutation) ClearField(name string) error {
	switch name {
	case mentorship.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Mentorship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentorshipMutation) ResetField(name string) error {
	switch name {
	case mentorship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mentorship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mentorship.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mentorship.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Mentorship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentorshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentorshipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentorshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentorshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentorshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentorshipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentorshipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Mentorship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentorshipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Mentorship edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op            Op
	typ           string
	id            *types.SkillID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	_type         *types.SkillType
	add_type      *types.SkillType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Skill, error)
	predicates    []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id types.SkillID) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Skill entities.
func (m *SkillMutation) SetID(id types.SkillID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id types.SkillID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[skill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[skill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, skill.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *SkillMutation) SetType(tt types.SkillType) {
	m._type = &tt
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *SkillMutation) GetType() (r types.SkillType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldType(ctx context.Context) (v types.SkillType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds tt to the "type" field.
func (m *SkillMutation) AddType(tt types.SkillType) {
	if m.add_type != nil {
		*m.add_type += tt
	} else {
		m.add_type = &tt
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *SkillMutation) AddedType() (r types.SkillType, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *SkillMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, skill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, skill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, skill.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m._type != nil {
		fields = append(fields, skill.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldCreatedAt:
		return m.CreatedAt()
	case skill.FieldUpdatedAt:
		return m.UpdatedAt()
	case skill.FieldDeletedAt:
		return m.DeletedAt()
	case skill.FieldName:
		return m.Name()
	case skill.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case skill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case skill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case skill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case skill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldType:
		v, ok := value.(types.SkillType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, skill.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case skill.FieldType:
		v, ok := value.(types.SkillType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldDeletedAt) {
		fields = append(fields, skill.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case skill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case skill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Skill edge %s", name)
}
